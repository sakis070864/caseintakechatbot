<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Intake Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icon Components ---
        const BotIcon = () => (
            <div className="w-9 h-9 rounded-full bg-gray-800 flex items-center justify-center flex-shrink-0">
                <svg className="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 2C9.243 2 7 4.243 7 7v3.5c0 .276-.224.5-.5.5S6 10.776 6 10.5V7c0-3.309 2.691-6 6-6s6 2.691 6 6v3.5c0 .276-.224.5-.5.5s-.5-.224-.5-.5V7c0-2.757-2.243-5-5-5zM9 14c-1.103 0-2 .897-2 2v2c0 1.103.897 2 2 2h6c1.103 0 2-.897 2-2v-2c0-1.103-.897-2-2-2H9z"></path>
                </svg>
            </div>
        );

        const UserIcon = () => (
            <div className="w-9 h-9 rounded-full bg-blue-600 flex items-center justify-center flex-shrink-0">
                <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
            </div>
        );

        const SendIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6">
                <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
            </svg>
        );

        const TypingIndicator = () => (
            <div className="flex items-center space-x-1 p-2">
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
                <div className="w-2 h-2 bg-gray-500 rounded-full animate-bounce"></div>
            </div>
        );

        const ChatMessage = ({ message, sender }) => (
            <div className={`flex items-start gap-3 my-4 ${sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                {sender === 'bot' && <BotIcon />}
                <div className={`px-4 py-2 rounded-lg max-w-lg ${sender === 'user' ? 'bg-blue-600 text-white' : 'bg-white text-gray-800'}`}>
                    {message}
                </div>
                {sender === 'user' && <UserIcon />}
            </div>
        );
        
        const ContactForm = ({ onSubmit }) => {
            const [name, setName] = useState('');
            const [email, setEmail] = useState('');
            const [phone, setPhone] = useState('');
            
            const handleSubmit = (e) => {
                e.preventDefault();
                if (name && email) {
                    onSubmit({ name, email, phone });
                }
            };

            return (
                <div className="p-4 bg-white rounded-lg shadow-md mb-4">
                    <h3 className="font-bold text-lg mb-2">Client Information</h3>
                    <p className="text-sm text-gray-600 mb-4">Please provide your contact details to begin.</p>
                    <form onSubmit={handleSubmit} className="space-y-4">
                         <input type="text" placeholder="Full Name" value={name} onChange={e => setName(e.target.value)} required className="w-full p-2 border rounded-md" />
                         <input type="email" placeholder="Email Address" value={email} onChange={e => setEmail(e.target.value)} required className="w-full p-2 border rounded-md" />
                         <input type="tel" placeholder="Phone Number (Optional)" value={phone} onChange={e => setPhone(e.target.value)} className="w-full p-2 border rounded-md" />
                         <button type="submit" className="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700 transition-colors">Start Intake</button>
                    </form>
                </div>
            );
        };


        function App() {
            const [userInput, setUserInput] = useState('');
            const [messages, setMessages] = useState([]);
            const [isLoading, setIsLoading] = useState(false);
            const [appState, setAppState] = useState('collecting_contact'); // collecting_contact, initial_prompt, asking_questions, interview_complete, generating_report, done
            const [clientInfo, setClientInfo] = useState(null);
            const [interviewPlan, setInterviewPlan] = useState(null);
            const [interviewData, setInterviewData] = useState([]);
            const [currentCategoryIndex, setCurrentCategoryIndex] = useState(0);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [initialCaseDescription, setInitialCaseDescription] = useState('');
            const [reportFailed, setReportFailed] = useState(false);
            const chatEndRef = useRef(null);
            
            const backendUrl = 'https://caseintake.onrender.com';

            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages, isLoading]);

            const addMessage = (text, sender) => {
                setMessages(prev => [...prev, { text, sender }]);
            };
            
            const handleContactSubmit = (info) => {
                setClientInfo(info);
                addMessage(`Thank you, ${info.name}. To start, please describe your situation below.`, 'bot');
                setAppState('initial_prompt');
            };

            const askNextQuestion = useCallback(() => {
                if (!interviewPlan) return;
                
                let category = interviewPlan.categories[currentCategoryIndex];
                if (category && category.questions[currentQuestionIndex]) {
                    if (currentQuestionIndex === 0 && currentCategoryIndex > 0) {
                       addMessage(`Great, thank you. Now for the next section: **${category.category_name}**`, 'bot');
                    }
                    const question = category.questions[currentQuestionIndex];
                    // **MODIFICATION**: Display the numbered question
                    addMessage(`${question.number}. ${question.question}`, 'bot');
                } else {
                    setCurrentCategoryIndex(prev => prev + 1);
                    setCurrentQuestionIndex(0);
                }
            }, [interviewPlan, currentCategoryIndex, currentQuestionIndex]);

            useEffect(() => {
                if (appState === 'asking_questions' && interviewPlan) {
                    if (currentCategoryIndex >= interviewPlan.categories.length) {
                        addMessage(interviewPlan.conclusion, 'bot');
                        setAppState('interview_complete');
                    } else {
                        askNextQuestion();
                    }
                }
            }, [appState, interviewPlan, currentCategoryIndex, currentQuestionIndex, askNextQuestion]);
            
            useEffect(() => {
                if (appState === 'interview_complete') {
                    generateReport();
                }
            }, [appState]);

            const generateReport = async () => {
                setAppState('generating_report');
                addMessage("Thank you for providing this information. I will now compile your intake report. This may take a moment...", 'bot');
                setIsLoading(true);

                const fullTranscript = interviewData.map(item => `Q: ${item.question}\nA: ${item.answer}`).join('\n\n');
                const reportPrompt = `
                    As a senior paralegal, generate a professional, well-structured case intake memo based on the following information. The memo should be clear, concise, and ready for an attorney to review.

                    ### Client Information ###
                    - Name: ${clientInfo.name}
                    - Email: ${clientInfo.email}
                    - Phone: ${clientInfo.phone || 'Not provided'}

                    ***

                    ### Initial Case Description ###
                    The client initially described their situation as follows:
                    "${initialCaseDescription}"

                    ***

                    ### Detailed Interview Transcript ###
                    ${fullTranscript}

                    ***

                    ### Instructions ###
                    Synthesize all the above information into a formal intake memo. Structure the memo with clear headings (e.g., "Summary of Facts", "Potential Legal Issues", "Client's Stated Goals"). Do not simply list the questions and answers; integrate the information into a narrative or summary format. Conclude with a "Next Steps" section.
                `;

                try {
                    const response = await fetch(`${backendUrl}/api/gemini`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: reportPrompt })
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || "Failed to generate report.");
                    
                    const reportContent = data.candidates[0].content.parts[0].text;
                    
                    await fetch(`${backendUrl}/api/save-report`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            clientName: clientInfo.name,
                            clientEmail: clientInfo.email,
                            clientPhone: clientInfo.phone,
                            reportContent: reportContent
                        })
                    });
                    
                    addMessage("Your case intake report has been successfully generated and sent to our team for review. We will be in contact with you shortly. Thank you for using our service.", 'bot');
                    setReportFailed(false);
                    setAppState('done');

                } catch (err) {
                    addMessage(`I'm sorry, I encountered an error while finalizing your report. Please try again. Error: ${err.message}`, 'bot');
                    setReportFailed(true);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleSendMessage = async () => {
                if (!userInput.trim()) return;
                const currentInput = userInput;
                addMessage(currentInput, 'user');
                setUserInput('');
                setIsLoading(true);

                try {
                    // --- Initial Prompt State ---
                    if (appState === 'initial_prompt') {
                        setInitialCaseDescription(currentInput);
                        // **MODIFICATION**: Updated prompt to request numbered questions
                        const planPrompt = `
                            You are an expert lawyer chatbot starting a client intake. 
                            The user has provided their initial situation. Your task is to generate a structured JSON object to guide the rest of the interview.
                            The JSON must have three keys: "introduction" (a brief, welcoming message confirming you've understood their initial query), "categories" (an array of question categories), and "conclusion" (a closing message for the end of the interview).
                            Each object in the "categories" array must have a "category_name" and a "questions" array.
                            Each object in the "questions" array MUST have two keys: "number" (a string like "1.1", "1.2", "2.1") and "question" (the question text).
                            Base the questions on the user's situation below. Do not ask for their name or contact details as they have already been provided.
                            User's situation: "${currentInput}"
                        `;
                        const response = await fetch(`${backendUrl}/api/gemini`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt: planPrompt, jsonMode: true })
                        });
                        const data = await response.json();
                        if (!response.ok) throw new Error(data.error || 'Failed to prepare interview.');
                        
                        const responseText = data.candidates[0].content.parts[0].text;
                        const parsedPlan = JSON.parse(responseText);

                        if (parsedPlan && parsedPlan.categories && parsedPlan.introduction) {
                            setInterviewPlan(parsedPlan);
                            addMessage(parsedPlan.introduction, 'bot');
                            setAppState('asking_questions');
                        } else {
                            throw new Error("Received an invalid interview plan from the AI.");
                        }
                    } 
                    // --- Asking Questions State ---
                    else if (appState === 'asking_questions') {
                        // **MODIFICATION**: Check if user input is a question
                        if (currentInput.trim().endsWith('?')) {
                            const questionPrompt = `
                                A client is in the middle of a legal intake interview.
                                They have just asked a clarifying question instead of answering the interview question.
                                Provide a concise and helpful answer to the client's question.
                                The current interview question was: "${interviewPlan.categories[currentCategoryIndex].questions[currentQuestionIndex].question}"
                                The client's question is: "${currentInput}"
                                Answer the client's question directly.
                            `;
                             const response = await fetch(`${backendUrl}/api/gemini`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt: questionPrompt })
                            });
                            const data = await response.json();
                            if (!response.ok) throw new Error(data.error || 'Could not process question.');

                            const answer = data.candidates[0].content.parts[0].text;
                            addMessage(answer, 'bot');
                            // Re-ask the original question
                            const originalQuestion = interviewPlan.categories[currentCategoryIndex].questions[currentQuestionIndex];
                            addMessage(`${originalQuestion.number}. ${originalQuestion.question}`, 'bot');

                        } else {
                            // This is an answer, so record it and move on
                            const questionAsked = interviewPlan.categories[currentCategoryIndex].questions[currentQuestionIndex];
                             setInterviewData(prev => [...prev, { 
                                question: `${questionAsked.number}. ${questionAsked.question}`, 
                                answer: currentInput 
                            }]);

                            if (currentQuestionIndex < interviewPlan.categories[currentCategoryIndex].questions.length - 1) {
                                setCurrentQuestionIndex(prev => prev + 1);
                            } else {
                                setCurrentCategoryIndex(prev => prev + 1);
                                setCurrentQuestionIndex(0);
                            }
                        }
                    }

                } catch (err) {
                    addMessage(`I'm sorry, I encountered a technical issue. Please try sending your message again. Error: ${err.message}`, 'bot');
                } finally {
                    setIsLoading(false);
                }
            };
            
            const isInputDisabled = appState === 'collecting_contact' || appState === 'generating_report' || appState === 'done' || isLoading;

            return (
                <div className="flex flex-col h-screen max-w-3xl mx-auto p-4">
                    <header className="text-center mb-4">
                        <h1 className="text-2xl font-bold text-gray-800">Legal Intake Assistant</h1>
                    </header>
                    <div className="flex-grow bg-gray-200 p-4 rounded-lg overflow-y-auto">
                        {appState === 'collecting_contact' && <ContactForm onSubmit={handleContactSubmit} />}
                        {messages.map((msg, index) => <ChatMessage key={index} message={msg.text} sender={msg.sender} />)}
                        {isLoading && <div className="flex justify-start"><TypingIndicator /></div>}
                        <div ref={chatEndRef} />
                    </div>
                    <div className="mt-4 flex items-center gap-2">
                        <input
                            type="text"
                            value={userInput}
                            onChange={(e) => setUserInput(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && !isInputDisabled && handleSendMessage()}
                            placeholder={isInputDisabled ? '...' : 'Describe your legal case here...'}
                            className="flex-grow p-3 border rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500"
                            disabled={isInputDisabled}
                        />
                         <button onClick={handleSendMessage} disabled={isInputDisabled} className="bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 disabled:bg-blue-300">
                           <SendIcon />
                        </button>
                    </div>
                    {reportFailed && <button onClick={generateReport} className="mt-2 w-full bg-red-500 text-white font-bold py-2 px-4 rounded-md hover:bg-red-600">Retry Report Generation</button>}
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
