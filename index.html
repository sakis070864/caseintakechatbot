<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Intake Assistant</title>
    <!-- 1. Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 2. React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- 3. Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- UI & Icon Components ---
        const SendIcon = () => (
          <svg viewBox="0 0 24 24" className="w-6 h-6" fill="currentColor">
            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
          </svg>
        );

        const BotIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-7 h-7 text-white">
                <path d="M4.75 2.75C4.75 2.19772 5.19772 1.75 5.75 1.75H18.25C18.8023 1.75 19.25 2.19772 19.25 2.75V10.25C19.25 10.8023 18.8023 11.25 18.25 11.25H5.75C5.19772 11.25 4.75 10.8023 4.75 10.25V2.75ZM5.75 21.25C5.19772 21.25 4.75 20.8023 4.75 20.25V12.75C4.75 12.1977 5.19772 11.75 5.75 11.75H18.25C18.8023 11.75 19.25 12.1977 19.25 12.75V20.25C19.25 20.8023 18.8023 21.25 18.25 21.25H5.75Z" />
                <path d="M9.25 6.5C9.25 7.05228 8.80228 7.5 8.25 7.5C7.69772 7.5 7.25 7.05228 7.25 6.5C7.25 5.94772 7.69772 5.5 8.25 5.5C8.80228 5.5 9.25 5.94772 9.25 6.5Z" />
                <path d="M16.25 6.5C16.25 7.05228 15.8023 7.5 15.25 7.5C14.6977 7.5 14.25 7.05228 14.25 6.5C14.25 5.94772 14.6977 5.5 15.25 5.5C15.8023 5.5 16.25 5.94772 16.25 6.5Z" />
                <path d="M13.25 16C13.25 16.4142 12.9142 16.75 12.5 16.75H11.5C11.0858 16.75 10.75 16.4142 10.75 16C10.75 15.5858 11.0858 15.25 11.5 15.25H12.5C12.9142 15.25 13.25 15.5858 13.25 16Z" />
            </svg>
        );

        const UserIcon = () => (
          <svg viewBox="0 0 24 24" className="w-7 h-7 text-gray-600" fill="currentColor">
            <path fillRule="evenodd" clipRule="evenodd" d="M12 20.25c-4.274 0-8.25-3.476-8.25-7.75S7.726 4.75 12 4.75s8.25 3.476 8.25 7.75-3.976 7.75-8.25 7.75Zm0 1.5A9.75 9.75 0 1 0 12 2.75a9.75 9.75 0 0 0 0 17.25Z" />
            <path fillRule="evenodd" clipRule="evenodd" d="M12 14.25a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Zm0 1.5a5.25 5.25 0 1 0 0-10.5 5.25 5.25 0 0 0 0 10.5Z" />
          </svg>
        );

        const ChatMessage = ({ message }) => {
          const isBot = message.sender === 'bot';
          const renderText = (text) => {
            const paragraphs = text.split(/\n\s*\n/);
            return paragraphs.map((paragraph, pIndex) => {
                const isNumberedList = /^\s*\d+\./m.test(paragraph);
                if (isNumberedList) {
                    const listItems = paragraph.split('\n').filter(line => line.trim() !== '');
                    return (
                        <ol key={pIndex} className="list-decimal list-inside space-y-2 my-2">
                            {listItems.map((item, iIndex) => {
                                const cleanItem = item.replace(/^\s*\d+\.\s*/, '');
                                const parts = cleanItem.split(/(\*\*.*?\*\*)/g);
                                return <li key={iIndex}>{parts.map((part, partIndex) => part.startsWith('**') && part.endsWith('**') ? <strong key={partIndex}>{part.slice(2, -2)}</strong> : part)}</li>;
                            })}
                        </ol>
                    );
                }
                const parts = paragraph.split(/(\*\*.*?\*\*)/g);
                return <p key={pIndex} className="my-1">{parts.map((part, partIndex) => part.startsWith('**') && part.endsWith('**') ? <strong key={partIndex}>{part.slice(2, -2)}</strong> : part)}</p>;
            });
          };

          return (
            <div className={`flex items-start gap-3 my-4 ${isBot ? '' : 'flex-row-reverse'}`}>
              <div className={`flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center ${isBot ? 'bg-slate-800' : 'bg-gray-200'}`}>
                {isBot ? <BotIcon /> : <UserIcon />}
              </div>
              <div className={`max-w-2xl p-4 rounded-xl shadow-sm ${isBot ? 'bg-gray-100 text-gray-800 rounded-bl-none' : 'bg-blue-600 text-white rounded-br-none'}`}>
                <div className="prose prose-sm max-w-none whitespace-pre-wrap">{renderText(message.text)}</div>
              </div>
            </div>
          );
        };

        // --- Main App Component ---
        function App() {
          const [userInput, setUserInput] = useState('');
          const [messages, setMessages] = useState([
            { id: 1, text: "Hello! I am your Legal Intake Assistant. Please describe your case below, and I will generate a list of questions to start our conversation.", sender: 'bot' }
          ]);
          const [isLoading, setIsLoading] = useState(false);
          const [appState, setAppState] = useState('initial_prompt');
          const [generatedQuestions, setGeneratedQuestions] = useState([]);
          const [interviewData, setInterviewData] = useState([]);
          const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
          const [initialCaseDescription, setInitialCaseDescription] = useState('');
          const [reportFailed, setReportFailed] = useState(false);

          const chatEndRef = useRef(null);
          const lastId = useRef(messages.length);

          const getUniqueId = () => { lastId.current += 1; return lastId.current; };

          useEffect(() => { chatEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);

          const callBackendAPI = async (prompt) => {
            const API_ENDPOINT = 'https://caseintake.onrender.com/api/gemini'; 
            const response = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt })
            });
            const data = await response.json();
            if (!response.ok) {
                throw new Error(data.error || `Backend API Error: ${response.status}`);
            }
            if (data.candidates && data.candidates.length > 0 && data.candidates[0].content.parts.length > 0) {
                return data.candidates[0].content.parts[0].text.trim();
            }
            throw new Error("Received an empty or invalid response from the API.");
          };

          const startInterview = (questions) => {
            if (questions.length === 0) {
                setMessages(prev => [...prev, { id: getUniqueId(), text: "I couldn't formulate specific questions based on the description. Could you please provide more details?", sender: 'bot' }]);
                setAppState('initial_prompt');
                return;
            }
            setGeneratedQuestions(questions);
            setCurrentQuestionIndex(0);
            setAppState('interviewing');
            setMessages(prev => [...prev, { id: getUniqueId(), text: `Thank you. I have prepared some initial questions. Let's begin.\n\n**Question 1:** ${questions[0]}`, sender: 'bot' }]);
          };
          
          const generateReport = async () => {
            setIsLoading(true);
            setReportFailed(false);
            setAppState('generating_report');
            setMessages(prev => [...prev, { id: getUniqueId(), text: "Thank you. I am now compiling a professional case summary report...", sender: 'bot' }]);

            const currentDate = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
            });

            const reportPrompt = `
              You are a senior paralegal tasked with creating a professional case intake report.
              The report should be structured like a professional legal memo. Start with a header containing TO, FROM, DATE, and RE fields.
              The DATE must be today's date: ${currentDate}.
              After the header, synthesize ALL of the following information into a clear, structured, and professional report that a lawyer can use for an initial case evaluation.
              The report should include the following sections, clearly marked with bold headings:
              1.  **Case Summary:** A brief, one-paragraph overview of the client's core problem.
              2.  **Client's Initial Statement:** The original, unedited description provided by the client.
              3.  **Intake Interview Q&A:** A list of the questions asked and the client's corresponding answers.
              4.  **Key Facts & Timeline:** A bulleted list of the most important facts, dates, and figures extracted from the entire conversation.
              5.  **Potential Legal Issues:** A brief, high-level identification of potential areas of law that may be relevant (e.g., "Contract Law," "Corporate Law," "Potential Fraud"). Do not provide legal advice.
              Here is the information to use:
              ---
              **INITIAL CASE DESCRIPTION:**
              "${initialCaseDescription}"
              ---
              **INTERVIEW QUESTIONS & ANSWERS:**
              ${interviewData.map(item => `Q: ${item.question}\nA: ${item.answer}`).join('\n\n')}
              ---
              Now, please generate the complete case intake report, starting with the memo header.
            `;
            try {
                const reportText = await callBackendAPI(reportPrompt);
                setMessages(prev => [...prev, { id: getUniqueId(), text: reportText, sender: 'bot' }]);
                setAppState('done');
            } catch (error) {
                setMessages(prev => [...prev, { id: getUniqueId(), text: `Error generating report: ${error.message}. Please try again.`, sender: 'bot' }]);
                setReportFailed(true);
                setAppState('interview_complete');
            } finally {
                setIsLoading(false);
            }
          };

          const parseQuestions = (text) => text.split('\n').map(l => l.trim()).filter(l => /^\d+\./.test(l)).map(l => l.replace(/^\d+\.\s*/, '').trim()).filter(q => q.length > 1);
          const isClarificationRequest = (text) => ['don\'t understand', 'repeat', 'clarify', 'rephrase', 'explain'].some(k => text.toLowerCase().includes(k));
          const isFollowUpQuestion = (text) => text.includes('?');

          const handleSendMessage = async () => {
            if (!userInput.trim() || isLoading) return;
            const currentUserInput = userInput;
            setMessages(prev => [...prev, { id: getUniqueId(), text: currentUserInput, sender: 'user' }]);
            setUserInput('');
            setIsLoading(true);

            try {
                if (appState === 'initial_prompt') {
                    setInitialCaseDescription(currentUserInput);
                    const prompt = `You are an experienced lawyer. A client provides the following case description. Your task is to generate a list of critical questions to ask the client to start the case. Format your response ONLY as a numbered list. Do not include headings, summaries, or any text other than the questions themselves. Here is the case: "${currentUserInput}"`;
                    const responseText = await callBackendAPI(prompt);
                    startInterview(parseQuestions(responseText));
                } else if (appState === 'interviewing') {
                    const currentQuestion = generatedQuestions[currentQuestionIndex];
                    if (isClarificationRequest(currentUserInput)) {
                        const prompt = `You are a helpful legal assistant. A client did not understand the following question. Please rephrase it in a simpler, clearer way without losing the original intent. Do not add any conversational text, just provide the rephrased question.\n\nOriginal Question: "${currentQuestion}"`;
                        const rephrased = await callBackendAPI(prompt);
                        setMessages(prev => [...prev, { id: getUniqueId(), text: rephrased, sender: 'bot' }]);
                    } else if (isFollowUpQuestion(currentUserInput)) {
                        const prompt = `You are a helpful legal assistant conducting an interview. You just asked the client a question, and now they have a follow-up question for you. Provide a concise and helpful answer to the client's question, then politely prompt them to answer your original question again.\n\n**Your Original Question:** "${currentQuestion}"\n**Client's Follow-up Question:** "${currentUserInput}"`;
                        const answer = await callBackendAPI(prompt);
                        setMessages(prev => [...prev, { id: getUniqueId(), text: answer, sender: 'bot' }]);
                    } else {
                        setInterviewData(prev => [...prev, { question: currentQuestion, answer: currentUserInput }]);
                        const nextIndex = currentQuestionIndex + 1;
                        if (nextIndex < generatedQuestions.length) {
                            setCurrentQuestionIndex(nextIndex);
                            setMessages(prev => [...prev, { id: getUniqueId(), text: `**Question ${nextIndex + 1}:** ${generatedQuestions[nextIndex]}`, sender: 'bot' }]);
                        } else {
                            setAppState('interview_complete');
                            await generateReport();
                        }
                    }
                }
            } catch (error) {
                setMessages(prev => [...prev, { id: getUniqueId(), text: `Error: ${error.message}`, sender: 'bot' }]);
            } finally {
                setIsLoading(false);
            }
          };
          
          const getPlaceholderText = () => {
            switch(appState) {
                case 'initial_prompt': return 'Describe your legal case here...';
                case 'interviewing': return `Your answer... or ask a clarifying question.`;
                default: return 'The interview is complete.';
            }
          }

          return (
            <div className="flex flex-col h-screen bg-gray-50 font-sans text-gray-800">
              <header className="bg-white shadow-sm p-4 border-b border-gray-200 sticky top-0 z-10">
                <div className="max-w-4xl mx-auto flex justify-center items-center">
                    <h1 className="text-2xl font-semibold text-slate-800">Legal Intake Assistant</h1>
                </div>
              </header>

              <main className="flex-1 overflow-y-auto p-4">
                <div className="max-w-3xl mx-auto">
                  {messages.map(msg => <ChatMessage key={msg.id} message={msg} />)}
                  {isLoading && (
                    <div className="flex items-start gap-3 my-4">
                        <div className="flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center bg-slate-800"><BotIcon /></div>
                        <div className="max-w-xl p-4 rounded-xl shadow-sm bg-gray-100">
                            <div className="flex items-center space-x-2">
                                <div className="w-2.5 h-2.5 bg-slate-500 rounded-full animate-pulse"></div>
                                <div className="w-2.5 h-2.5 bg-slate-500 rounded-full animate-pulse" style={{ animationDelay: '0.2s' }}></div>
                                <div className="w-2.5 h-2.5 bg-slate-500 rounded-full animate-pulse" style={{ animationDelay: '0.4s' }}></div>
                            </div>
                        </div>
                    </div>
                  )}
                  <div ref={chatEndRef} />
                </div>
              </main>

              <footer className="bg-white/80 backdrop-blur-lg p-4 border-t border-gray-200 sticky bottom-0">
                <div className="max-w-3xl mx-auto">
                  {reportFailed ? (
                    <button
                      onClick={generateReport}
                      className="w-full p-3 rounded-lg bg-green-600 text-white font-semibold hover:bg-green-700 transition-colors"
                    >
                      Retry Report Generation
                    </button>
                  ) : (
                    <div className="flex items-center bg-white rounded-xl p-2 shadow-md border border-gray-200">
                      <textarea
                        value={userInput}
                        onChange={(e) => setUserInput(e.target.value)}
                        onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendMessage(); } }}
                        placeholder={getPlaceholderText()}
                        className="flex-1 bg-transparent p-2 border-none focus:outline-none focus:ring-0 resize-none text-base"
                        rows="1"
                        disabled={isLoading || appState === 'done' || appState === 'generating_report'}
                      />
                      <button
                        onClick={handleSendMessage}
                        disabled={isLoading || !userInput.trim() || appState === 'done' || appState === 'generating_report'}
                        className="p-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors duration-200"
                      >
                        <SendIcon />
                      </button>
                    </div>
                  )}
                </div>
              </footer>
            </div>
          );
        }

        // --- Render the App to the DOM ---
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);

    </script>
</body>
</html>
